<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Virtual Joystick Demo</title>
  <style>
    html, body { height: 100%; margin: 0; touch-action: none; }
    #game { width: 100%; height: 100%; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game"></div>
<script>
(() => {
  const SPEED = 200;
  const config = {
    type: Phaser.AUTO,
    parent: 'game',
    width: window.innerWidth,
    height: window.innerHeight,
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: { preload, create, update }
  };

  let player;
  let joystickBase, joystickThumb;
  const joystickVector = new Phaser.Math.Vector2();
  let joystickPointer = null;

  new Phaser.Game(config);

  function preload() {
    this.load.image('bg', '../images/background/background.png');
    // Load directional player sprites from the local assets folder
    this.load.image('playerFront', 'assets/boy_front.png');
    this.load.image('playerBack', 'assets/boy_back.png');
    this.load.image('playerLeft', 'assets/boy_left.png');
    this.load.image('playerRight', 'assets/boy_right.png');
    // Load the updated player sprite from the local assets folder
    this.load.image('player', 'assets/boy_front.png');
  }

  function create() {
    const { width, height } = this.scale;

    this.add.image(width / 2, height / 2, 'bg')
      .setDisplaySize(width, height);

    player = this.physics.add.image(width / 2, height / 2, 'playerFront')
    player = this.physics.add.image(width / .5, height / .5, 'player')
      .setCollideWorldBounds(true);
    player = this.physics.add.image(width / 2, height / 2, 'player')
      .setCollideWorldBounds(true)
      // Ensure the sprite displays at the intended size
      .setDisplaySize(150, 150);

    const baseRadius = 60;
    const thumbRadius = 30;
    const baseX = 90;
    const baseY = height - 90;

    joystickBase = this.add.circle(baseX, baseY, baseRadius, 0xffffff, 0.2)
      .setStrokeStyle(2, 0xffffff, 0.3)
      .setScrollFactor(0)
      .setInteractive();

    joystickThumb = this.add.circle(baseX, baseY, thumbRadius, 0xffffff, 0.8)
      .setScrollFactor(0);

    joystickBase.on('pointerdown', pointer => {
      joystickPointer = pointer.id;
      moveThumb(pointer);
    });

    this.input.on('pointermove', pointer => {
      if (pointer.id === joystickPointer) {
        moveThumb(pointer);
      }
    });

    this.input.on('pointerup', pointer => {
      if (pointer.id === joystickPointer) {
        joystickPointer = null;
        joystickThumb.x = joystickBase.x;
        joystickThumb.y = joystickBase.y;
        joystickVector.set(0, 0);
      }
    });

    function moveThumb(pointer) {
      const dx = pointer.x - joystickBase.x;
      const dy = pointer.y - joystickBase.y;
      joystickVector.set(dx, dy);
      const dist = Math.min(joystickVector.length(), baseRadius);
      const angle = joystickVector.angle();
      joystickThumb.x = joystickBase.x + Math.cos(angle) * dist;
      joystickThumb.y = joystickBase.y + Math.sin(angle) * dist;
    }
  }

  function update(time, delta) {
    if (joystickVector.length() > 0) {
      const dir = joystickVector.clone().normalize();
      player.x += dir.x * SPEED * (delta / 1000);
      player.y += dir.y * SPEED * (delta / 1000);

      let texture;
      if (Math.abs(dir.x) > Math.abs(dir.y)) {
        texture = dir.x > 0 ? 'playerRight' : 'playerLeft';
      } else {
        texture = dir.y > 0 ? 'playerFront' : 'playerBack';
      }
      player.setTexture(texture).setDisplaySize(150, 150);
    } else {
      player.setTexture('playerFront').setDisplaySize(150, 150);
    }
  }
})();
</script>
</body>
</html>
