<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Virtual Joystick Demo</title>
  <style>
    html, body { height: 100%; margin: 0; touch-action: none; overflow: hidden; }
    #game { width: 100%; height: 100%; }

    /* Glassy bits */
    .glass {
      border: none;
      border-radius: 50%;
      backdrop-filter: blur(4px);
    }

    /* Joystick */
    .joystick-base {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      box-sizing: border-box;
      background: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.2);
      cursor: pointer;
    }
    .joystick-thumb {
      position: absolute;
      max-height: 28px;
      max-width: 28px;
      background: linear-gradient(#FFAE00, #FF6A00);
      border: 3px solid #fff;
      border-radius: 50%;
      box-sizing: border-box;
    }

    /* Bottom controls bar */
    #controls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 40px 40px;
      box-sizing: border-box;
      pointer-events: none; /* allow game clicks except on actual controls */
    }
    #joystick-wrap, #actions {
      pointer-events: auto;
    }

    /* Actions row: two buttons side-by-side */
    #actions {
      display: flex;
      gap: 16px;
      align-items: center;
    }
    .action-btn {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      box-sizing: border-box;
      background: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.2);
      cursor: pointer;
    }
    .action-btn img {
      width: 24px;
      height: 24px;
      display: block;
    }
    .action-btn:active {
      transform: scale(0.96);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game"></div>

<script>
(() => {
  const SPEED = 200;
  const config = {
    type: Phaser.AUTO,
    parent: 'game',
    width: window.innerWidth,
    height: window.innerHeight,
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: { preload, create, update }
  };

  let player;
  let joystickBase, joystickThumb, joystickContainer;
  const joystickVector = new Phaser.Math.Vector2();
  let joystickPointer = null;
  let facing = 'right';
  let attackBtn, defendBtn, controls, actionsContainer, joystickWrap;
  let baseX, baseY;
  let playerBullets, enemyBullets, monsters;
  let shield = null, isShielded = false;
  let kills = 0, killText;
  let monsterTimer;
  let gameOverFlag = false;

  new Phaser.Game(config);

  function preload() {
    this.load.image('bg', '../images/background/background.png');
    this.load.image('playerLeft', 'assets/swim_shellfin_left.png');
    this.load.image('playerRight', 'assets/swim_shellfin_right.png');
    this.load.image('monsterLeft', 'assets/swim_monster_left.png');
    this.load.image('monsterRight', 'assets/swim_monster_right.png');
  }

  function create() {
    const { width, height } = this.scale;

    this.add.image(width / 2, height / 2, 'bg').setDisplaySize(width, height);

    player = this.physics.add.image(width / 2, height / 2, 'playerRight')
      .setCollideWorldBounds(true)
      .setDisplaySize(150, 150);

    playerBullets = this.physics.add.group();
    enemyBullets = this.physics.add.group();
    monsters = this.physics.add.group();

    killText = this.add.text(width / 2, 20, 'Kills: 0', { font: '24px Arial', fill: '#fff' }).setOrigin(0.5, 0);

    this.physics.add.overlap(playerBullets, monsters, hitMonster, null, this);
    this.physics.add.overlap(enemyBullets, player, hitPlayer, null, this);
    this.physics.add.overlap(player, monsters, hitPlayer, null, this);

    monsterTimer = this.time.addEvent({ delay: 3000, loop: true, callback: spawnMonster, callbackScope: this });

    const baseRadius = 36;
    const thumbRadius = 24;

    // === Controls Bar (Bottom) ===
    controls = document.createElement('div');
    controls.id = 'controls';
    document.body.appendChild(controls);

    // Left side: Joystick
    joystickWrap = document.createElement('div');
    joystickWrap.id = 'joystick-wrap';
    joystickWrap.style.position = 'relative';
    joystickWrap.style.width = `${baseRadius * 2}px`;
    joystickWrap.style.height = `${baseRadius * 2}px`;
    joystickWrap.className = 'glass';
    controls.appendChild(joystickWrap);

    joystickContainer = document.createElement('div');
    joystickContainer.style.position = 'relative';
    joystickContainer.style.width = `${baseRadius * 2}px`;
    joystickContainer.style.height = `${baseRadius * 2}px`;
    joystickWrap.appendChild(joystickContainer);

    joystickBase = document.createElement('div');
    joystickBase.className = 'joystick-base';
    joystickBase.style.width = `${baseRadius * 2}px`;
    joystickBase.style.height = `${baseRadius * 2}px`;
    joystickBase.style.left = '0';
    joystickBase.style.top = '0';
    joystickBase.style.touchAction = 'none';
    joystickContainer.appendChild(joystickBase);

    joystickThumb = document.createElement('div');
    joystickThumb.className = 'joystick-thumb';
    joystickThumb.style.width = `${thumbRadius * 2}px`;
    joystickThumb.style.height = `${thumbRadius * 2}px`;
    joystickThumb.style.left = `${baseRadius - thumbRadius}px`;
    joystickThumb.style.top = `${baseRadius - thumbRadius}px`;
    joystickThumb.style.touchAction = 'none';
    joystickContainer.appendChild(joystickThumb);

    // Right side: Actions (two buttons next to each other)
    actionsContainer = document.createElement('div');
    actionsContainer.id = 'actions';
    controls.appendChild(actionsContainer);

    attackBtn = document.createElement('button');
    attackBtn.type = 'button';
    attackBtn.className = 'action-btn';
    attackBtn.title = 'Attack';
    attackBtn.innerHTML = '<img src="assets/attack.png" alt="attack">';
    actionsContainer.appendChild(attackBtn);

    defendBtn = document.createElement('button');
    defendBtn.type = 'button';
    defendBtn.className = 'action-btn';
    defendBtn.title = 'Defend';
    defendBtn.innerHTML = '<img src="assets/defend.png" alt="defend">';
    actionsContainer.appendChild(defendBtn);

    // Compute joystick center after layout
    const rect = joystickContainer.getBoundingClientRect();
    baseX = rect.left + baseRadius;
    baseY = rect.top + baseRadius;

    // Bubble texture for attack
    const bubbleGfx = this.add.graphics();
    bubbleGfx.fillStyle(0x9bd7fb, 0.6).fillCircle(10, 10, 10);
    bubbleGfx.lineStyle(2, 0xffffff, 0.8).strokeCircle(10, 10, 10);
    bubbleGfx.generateTexture('bubble', 20, 20);
    bubbleGfx.destroy();

    // Joystick handlers
    joystickBase.addEventListener('pointerdown', startJoystick);
    joystickThumb.addEventListener('pointerdown', startJoystick);
    window.addEventListener('pointermove', moveJoystick);
    window.addEventListener('pointerup', endJoystick);

    this.input.on('pointerdown', pointer => {
      if (Phaser.Math.Distance.Between(pointer.x, pointer.y, baseX, baseY) <= baseRadius) {
        joystickPointer = pointer.id;
        moveThumb(pointer);
      }
    });

    function startJoystick(e) {
      joystickPointer = e.pointerId;
      moveThumb(e);
    }
    function moveJoystick(e) {
      if (e.pointerId === joystickPointer) moveThumb(e);
    }
    function endJoystick(e) {
      if (e.pointerId === joystickPointer) {
        joystickPointer = null;
        joystickThumb.style.left = `${baseRadius - thumbRadius}px`;
        joystickThumb.style.top  = `${baseRadius - thumbRadius}px`;
        joystickVector.set(0, 0);
      }
    }
    function moveThumb(pointer) {
      const dx = pointer.x - baseX;
      const dy = pointer.y - baseY;
      joystickVector.set(dx, dy);
      const dist = Math.min(joystickVector.length(), baseRadius);
      const angle = joystickVector.angle();
      joystickThumb.style.left = `${baseRadius - thumbRadius + Math.cos(angle) * dist}px`;
      joystickThumb.style.top  = `${baseRadius - thumbRadius + Math.sin(angle) * dist}px`;
    }

    // === Actions ===
    attackBtn.addEventListener('pointerdown', () => {
      const offset = facing === 'right' ? 60 : -60;
      const bubble = playerBullets.create(player.x + offset, player.y, 'bubble');
      bubble.setVelocity(facing === 'right' ? 300 : -300, 0);
      this.time.delayedCall(5000, () => bubble.destroy());
    });

    defendBtn.addEventListener('pointerdown', () => {
      if (isShielded) return;
      isShielded = true;
      shield = this.add.circle(player.x, player.y, 80, 0x00ffff, 0.2).setStrokeStyle(2, 0xffffff);
      this.time.delayedCall(2000, () => {
        shield.destroy();
        shield = null;
        isShielded = false;
      });
    });

    window._speedMultiplier = 1;

    // Recompute joystick center on resize
    window.addEventListener('resize', () => {
      const r = joystickContainer.getBoundingClientRect();
      baseX = r.left + baseRadius;
      baseY = r.top + baseRadius;
    });

    function spawnMonster() {
      const side = Phaser.Math.Between(0, 1) === 0 ? 'left' : 'right';
      const y = Phaser.Math.Between(100, height - 100);
      const texture = side === 'left' ? 'monsterRight' : 'monsterLeft';
      const x = side === 'left' ? -50 : width + 50;
      const monster = monsters.create(x, y, texture).setDisplaySize(150, 150);
      monster.side = side;
      monster.setVelocityX(side === 'left' ? 50 : -50);

      this.time.addEvent({
        delay: 1500,
        loop: true,
        callback: () => {
          if (!monster.active) return;
          const offset = monster.side === 'left' ? 60 : -60;
          const bullet = enemyBullets.create(monster.x + offset, monster.y, 'bubble');
          bullet.setVelocity(monster.side === 'left' ? 300 : -300, 0);
          this.time.delayedCall(5000, () => bullet.destroy());
        }
      });

      this.time.delayedCall(20000, () => { if (monster.active) monster.destroy(); });
    }

    function hitMonster(bubble, monster) {
      bubble.destroy();
      this.tweens.add({
        targets: monster,
        scale: 0,
        alpha: 0,
        duration: 200,
        onComplete: () => monster.destroy()
      });
      kills++;
      killText.setText(`Kills: ${kills}`);
    }

    function hitPlayer(playerSprite, threat) {
      threat.destroy();
      if (isShielded) return;
      gameOver.call(this);
    }

    function gameOver() {
      if (gameOverFlag) return;
      gameOverFlag = true;
      this.physics.pause();
      monsterTimer.remove();

      joystickBase.removeEventListener('pointerdown', startJoystick);
      joystickThumb.removeEventListener('pointerdown', startJoystick);
      window.removeEventListener('pointermove', moveJoystick);
      window.removeEventListener('pointerup', endJoystick);

      controls.remove();
      killText.destroy();
      if (shield) { shield.destroy(); shield = null; }
      player.destroy();
      monsters.clear(true, true);
      playerBullets.clear(true, true);
      enemyBullets.clear(true, true);

      const centerX = width / 2;
      const centerY = height / 2;
      this.add.text(centerX, centerY - 40, 'You Lose', { font: '48px Arial', fill: '#fff' }).setOrigin(0.5);
      this.add.text(centerX, centerY, `Score: ${kills}`, { font: '32px Arial', fill: '#fff' }).setOrigin(0.5);

      const btn = document.createElement('button');
      btn.textContent = 'Try Again';
      btn.style.position = 'absolute';
      btn.style.left = '50%';
      btn.style.top = `${centerY + 40}px`;
      btn.style.transform = 'translateX(-50%)';
      document.body.appendChild(btn);
      btn.addEventListener('click', () => location.reload());
    }
  }

  function update(time, delta) {
    const dt = (delta / 1000) * (window._speedMultiplier || 1);

    if (joystickVector.length() > 0) {
      const dir = joystickVector.clone().normalize();
      player.x += dir.x * SPEED * dt;
      player.y += dir.y * SPEED * dt;

      if (Math.abs(dir.x) > 0.1) {
        facing = dir.x > 0 ? 'right' : 'left';
      }
      player.setTexture(facing === 'right' ? 'playerRight' : 'playerLeft').setDisplaySize(150, 150);
    } else {
      player.setTexture(facing === 'right' ? 'playerRight' : 'playerLeft').setDisplaySize(150, 150);
    }

    if (shield) {
      shield.x = player.x;
      shield.y = player.y;
    }

    monsters.children.iterate(m => {
      if (m.x < -100 || m.x > this.scale.width + 100) m.destroy();
    });
  }
})();
</script>
</body>
</html>
