<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phaser 3 â€” 16Ã—16 Tilemap + Grid Movement Demo</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0b1020; }
    #game { width: 100%; height: 100%; }
    .hint { position: fixed; left: 12px; bottom: 12px; color: #cfe3ff; font: 12px/1.4 system-ui, sans-serif; opacity:.9 }
    .hint code { background: #1a2240; padding:2px 4px; border-radius:4px }
  </style>
  <!-- Phaser 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game"></div>
  <div class="hint">
    Replace image paths in <code>preload()</code> with your files:<br>
    <code>assets/tiles.png</code> â†’ 2Ã—2 grid (16Ã—16 each): wood, water, sand, grass<br>
    <code>assets/boy_front.png</code>, <code>boy_back.png</code>, <code>boy_left.png</code>, <code>boy_right.png</code> (each 16Ã—16)
  </div>

<script>
(() => {
  const TILE = 128;               // Each tile is 16Ã—16
  const SCALE = 2;               // Upscale for crisp pixels on modern screens
  const SPEED = 600;             // pixels/second for tweened tile steps

  const config = {
    type: Phaser.AUTO,
    parent: 'game',
    backgroundColor: '#2b3352',
    pixelArt: true,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 20*TILE*SCALE, height: 12*TILE*SCALE },
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: { preload, create, update }
  };

  new Phaser.Game(config);

  // --- Asset keys
  const KEYS = {
    tiles: 'tiles',
    boyFront: 'boyFront',
    boyBack:  'boyBack',
    boyLeft:  'boyLeft',
    boyRight: 'boyRight'
  };

  // Map indices: using a 2Ã—2 tilesheet (32Ã—32) of 16Ã—16 tiles
  // Layout expected:
  // [0] wood | [1] water
  // [2] sand | [3] grass
  const TILE_INDEX = { WOOD:0, WATER:1, SAND:2, GRASS:3 };

  // Simple demo map (20Ã—12 tiles). 1 = water (blocked), others walkable.
  const worldMap = [
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1],
    [2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2],
    [2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,3,3,3,2,2],
    [2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,3,3,3,2,2],
    [2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,3,3,3,2,2]
  ];

  let cursors, player, map, layer, moving = false, targetTile = null, camera;

  function preload() {
    // ðŸ” Replace these paths with your files
    this.load.spritesheet(KEYS.tiles, 'assets/tiles.png', { frameWidth: TILE, frameHeight: TILE });
    this.load.image(KEYS.boyFront, 'assets/boy_front.png');
    this.load.image(KEYS.boyBack,  'assets/boy_back.png');
    this.load.image(KEYS.boyLeft,  'assets/boy_left.png');
    this.load.image(KEYS.boyRight, 'assets/boy_right.png');
  }

  function create() {
    // Create tilemap from data
    map = this.make.tilemap({ data: worldMap, tileWidth: TILE, tileHeight: TILE });
    const tileset = map.addTilesetImage(KEYS.tiles);
    layer = map.createLayer(0, tileset, 0, 0);
    layer.setScale(SCALE);

    // Mark water (index 1) as colliding
    layer.setCollision([TILE_INDEX.WATER]);

    // Player
    const startX = 10, startY = 2; // tile coords
    player = this.add.image((startX+0.5)*TILE*SCALE, (startY+0.5)*TILE*SCALE, KEYS.boyFront)
                     .setOrigin(0.5)
                     .setScale(SCALE)
                     .setDepth(10);

    // Set up camera to follow player
    camera = this.cameras.main;
    camera.setBounds(0, 0, map.widthInPixels*SCALE, map.heightInPixels*SCALE);
    camera.startFollow(player, true, 0.2, 0.2);

    cursors = this.input.keyboard.createCursorKeys();

    // Ensure crisp pixels
    this.game.renderer.pixelArt = true;
  }

  function update(time, delta) {
    if (moving) return; // Don't accept input mid-move

    let dx = 0, dy = 0, facingKey = null;
    if (Phaser.Input.Keyboard.JustDown(cursors.left))  { dx = -1; facingKey = KEYS.boyLeft; }
    else if (Phaser.Input.Keyboard.JustDown(cursors.right)) { dx = 1; facingKey = KEYS.boyRight; }
    else if (Phaser.Input.Keyboard.JustDown(cursors.up))    { dy = -1; facingKey = KEYS.boyBack; }
    else if (Phaser.Input.Keyboard.JustDown(cursors.down))  { dy = 1; facingKey = KEYS.boyFront; }

    if (dx === 0 && dy === 0) return;

    const { x:tileX, y:tileY } = worldToTile(player.x, player.y);
    const nx = tileX + dx;
    const ny = tileY + dy;

    if (!inBounds(nx, ny)) { // out of map
      player.setTexture(facingKey); return;
    }

    const tile = map.getTileAt(nx, ny);
    if (tile && tile.index === TILE_INDEX.WATER) { // blocked
      player.setTexture(facingKey); return;
    }

    player.setTexture(facingKey);
    moveToTile(nx, ny);
  }

  function moveToTile(tx, ty) {
    moving = true;
    const px = (tx + 0.5) * TILE * SCALE;
    const py = (ty + 0.5) * TILE * SCALE;

    // Tween to keep movement smooth but grid-locked
    player.scene.tweens.add({
      targets: player,
      x: px,
      y: py,
      duration: Math.round((TILE * SCALE) / SPEED * 1000),
      ease: 'Linear',
      onComplete: () => { moving = false; }
    });
  }

  function worldToTile(wx, wy) {
    return {
      x: Math.floor(wx / (TILE*SCALE)),
      y: Math.floor(wy / (TILE*SCALE))
    };
  }

  function inBounds(x, y) {
    return x >= 0 && y >= 0 && x < map.width && y < map.height;
  }
})();
</script>
</body>
</html>
